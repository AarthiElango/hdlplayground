import { useEffect, useRef, useState } from "react";

// Basic VCD waveform canvas viewer
export default function VcdWaveformViewer({ vcd }:{vcd:any}) {
  const canvasRef:any = useRef(null);
  const [zoom, setZoom] = useState(1);
  const [signals, setSignals] = useState<any>([]);
  const [parsed, setParsed] = useState<any>(null);
  const [hoverTime, setHoverTime] = useState<any>(null);
  const [collapsed, setCollapsed] = useState<any>({});

  // --- Simple VCD Parser (very minimal) ---
  function parseVCD(text: any) {
  const lines = text.split(/\r?\n/);
  const idToName: any = {};
  const values: any = {};
  const events: any = [];

  let currentTime = 0;

  for (let rawLine of lines) {
    const line = rawLine.trim();
    if (!line) continue;

    // -------------------------
    // $var definitions
    // -------------------------
    if (line.startsWith("$var")) {
      const parts = line.split(/\s+/);
      const id = parts[3]?.trim();
      const name = parts[4]?.trim();

      if (id) {
        idToName[id] = name;
        values[id] = [];
      }
      continue;
    }

    // -------------------------
    // Time marker #<time>
    // -------------------------
    if (line.startsWith("#")) {
      const t = parseInt(line.slice(1).trim(), 10);
      if (!isNaN(t)) {
        currentTime = t;
        events.push({ time: currentTime, changes: [] });
      }
      continue;
    }

    // -------------------------
    // Binary bus update: bxxxx <id>
    // Example:  b1001 $
    // -------------------------
    if (line.startsWith("b")) {
      const match = line.match(/b([01xXzZ]+)\s+(.*)/);
      if (!match) continue;

      const bin = match[1];
      const id = match[2].trim();

      if (values[id]) {
        values[id].push({ time: currentTime, value: bin });
        events[events.length - 1].changes.push({ id, value: bin });
      }
      continue;
    }

    // -------------------------
    // Single-bit change: 1<id>, 0<id>, x<id>
    // Example:  1"   or   0#
    // -------------------------
    if (/^[01xXzZ]/.test(line)) {
      const val = line[0];
      const id = line.slice(1).trim();

      if (values[id]) {
        values[id].push({ time: currentTime, value: val });
        events[events.length - 1].changes.push({ id, value: val });
      }
      continue;
    }
  }

  return { idToName, values, events };
}

  // Parse VCD whenever vcd changes
  useEffect(() => {
    if (vcd) {
      const p:any = parseVCD(vcd);
      setParsed(p);
      setSignals(Object.keys(p.idToName));
    }
  }, [vcd]);

  // Draw waveform to canvas
  useEffect(() => {
    if (!parsed) return;
    const canvas:any = canvasRef.current;
    const ctx = canvas.getContext("2d");

    const width = canvas.width = canvas.clientWidth;
    const height = canvas.height = signals.length * 40 + 50;

    ctx.clearRect(0, 0, width, height);
    ctx.font = "12px sans-serif";

    signals.forEach((id:any, i:any) => {
      const y = i * 40 + 30;

      // Skip if collapsed
      const isCollapsed = collapsed[id];

      ctx.fillStyle = "black";
      ctx.fillText(parsed.idToName[id], 10, y - 10);

      const arr = parsed.values[id] || [];
      let prev:any = null;

      arr.forEach((ev:any, idx:any) => {
        const x = ev.time * zoom + 150;

        if (!isCollapsed) {
          if (prev !== null) {
            // draw horizontal
            ctx.strokeStyle = "black";
            ctx.beginPath();
            ctx.moveTo(prev.x, y - (prev.value === "1" ? 15 : -15));
            ctx.lineTo(x, y - (prev.value === "1" ? 15 : -15));
            ctx.stroke();

            // vertical transition
            ctx.beginPath();
            ctx.moveTo(x, y - (prev.value === "1" ? 15 : -15));
            ctx.lineTo(x, y - (ev.value === "1" ? 15 : -15));
            ctx.stroke();
          }
        }

        prev = { x, value: ev.value };
      });
    });

    // Draw hover marker
    if (hoverTime !== null) {
      const x = hoverTime * zoom + 150;
      ctx.strokeStyle = "red";
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();

      ctx.fillStyle = "red";
      ctx.fillText(`t=${hoverTime}`, x + 5, 15);
    }
  }, [parsed, zoom, signals, hoverTime, collapsed]);

  // Mouse move handler
  function onMove(e:any) {
    const rect = canvasRef.current.getBoundingClientRect();
    const x = e.clientX - rect.left - 150;
    const t = Math.round(x / zoom);
    setHoverTime(t >= 0 ? t : null);
  }

  return (
    <div className="p-4 space-y-4">
      <div className="flex items-center gap-4">
        <button onClick={() => setZoom((z) => z * 1.2)} className="px-2 py-1 bg-blue-200 rounded">Zoom In</button>
        <button onClick={() => setZoom((z) => z / 1.2)} className="px-2 py-1 bg-blue-200 rounded">Zoom Out</button>
      </div>

      <div className="border relative w-full overflow-auto" style={{ height: "600px"}}>
        <canvas ref={canvasRef} onMouseMove={onMove} className="w-full h-full" />
      </div>

      <div>
        {signals.map((id:any) => (
          <div key={id} className="cursor-pointer" onClick={() => setCollapsed({ ...collapsed, [id]: !collapsed[id] })}>
            {collapsed[id] ? "▶" : "▼"} {parsed?.idToName[id]}
          </div>
        ))}
      </div>
    </div>
  );
}
